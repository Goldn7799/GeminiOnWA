/**
 * @license
 * Copyright 2025 SGStudio Under Syeif Sultoni Akbar & APDev
 * 
 * Licensed under GNU General Public License Version 3 (the "License")
 * For more information on this, see
 * 
 *  https://www.gnu.org/licenses/
 * 
 * To "modify" a work means to copy from or adapt all or part of the work
 * in a fashion requiring copyright permission, other than the making of an
 * exact copy.  The resulting work is called a "modified version" of the
 * earlier work or a work "based on" the earlier work.
 */

///////////////////////////////////
// THIS SCRIPT UNDER DEVELOPMENT //
///////////////////////////////////

import { getContentType, jidDecode, proto, type FullJid, type WAMessage, type WASocket } from '@whiskeysockets/baileys'

interface ParsedQuotedMessage extends proto.IWebMessageInfo {
	id: string | undefined | null,
	fromMe: boolean | undefined | null,
	sender: string | FullJid | undefined | null,
	type: keyof proto.IMessage | undefined | null,
	text: string | undefined |null
}

interface ParsedMessage {
	id: string | undefined | null,
	chat: string | undefined | null,
	fromMe: boolean | undefined | null,
	isGroup: boolean | undefined | null,
	sender: string | FullJid | undefined | null,
	participant: string | FullJid | undefined | null,
	type: keyof proto.IMessage | undefined | null,
	msg: proto.IMessage | undefined | null,
	quoted: ParsedQuotedMessage | undefined | null
}

const messageParser = (sock: WASocket, m: WAMessage) => {
	const decodeJid = (jid: string | undefined | null): string | FullJid | undefined | null => {
		if (!jid) return jid;
		if (/:\d+@/gi.test(jid)) {
			const jidDec = jidDecode(jid)
			if (jidDec) {
				const decode: FullJid = jidDec;
				return (decode.user && decode.server && decode.user + "@" + decode.server);
			} else {
				return jid;
			}
		} else return jid;
	};
	if (!m) return m;

	const M: ParsedMessage = {
		id: undefined,
		chat: undefined,
		fromMe: undefined,
		isGroup: undefined,
		sender: undefined,
		participant: undefined,
		type: undefined,
		msg: undefined,
		quoted: undefined
	}

	if (m.key) {
		M.id = m.key.id;
		M.chat = m.key.remoteJid;
		M.fromMe = m.key.fromMe;
		M.isGroup = M.chat?.endsWith("@g.us");
		M.sender = decodeJid((m.key.fromMe) ? sock.user?.id : (m.participant || m.key.participant || m.key.remoteJid))
		if (M.isGroup) M.participant = decodeJid(m.key.participant);
	};
	
	if (m.message && M.type) {
		M.type = getContentType(m.message)
		M.msg = m.message
		// if (M.type == "viewOnceMessage") {
		// 	const optionARaw = m.message[`${M.type}`]?.message
		// 	const optionAWell = (optionARaw) ? optionARaw : undefined
		// 	const contentType = getContentType(optionAWell)
		// 	if (contentType) {
		// 		const optionA = (optionAWell) ? optionAWell[contentType] : undefined
		// 		const optionB = m.message[`${M.type}`]
		// 		if (optionA) {
		// 			M.msg = optionA
		// 		} else {
		// 			M.msg = optionB
		// 		}
		// 	}
		// }

		const quoted = M.quoted = (m.message.extendedTextMessage?.contextInfo && m.message.extendedTextMessage.contextInfo.quotedMessage) ? JSON.parse(JSON.stringify(m.message.extendedTextMessage?.contextInfo.quotedMessage)) : undefined

		if (M.quoted) {
			const RawContentType = getContentType(quoted)
			const ContentType = (RawContentType) ? RawContentType : 'imageMessage'
			// M.quoted = M.quoted[`${ContentType}`]
			M.quoted.type = ContentType
			M.quoted.id = M.msg.extendedTextMessage?.contextInfo?.stanzaId
			// M.quoted.chat = M.msg.extendedTextMessage?.contextInfo?.remoteJid || m.key.remoteJid
			M.quoted.sender = decodeJid(M.msg.extendedTextMessage?.contextInfo?.participant)
			M.quoted.fromMe = M.quoted.sender === (sock.user && sock.user.id)
		}
	}
	return M;
};

export default messageParser